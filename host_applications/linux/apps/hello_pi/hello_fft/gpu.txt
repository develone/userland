e^ix = cosx + isinx

using the existing functions and the mailbox.c code from hello_fft it should be possible 
to create Pascal implementations of those as well. See the RPi3GPUMemoryAllocate, 
RPi3GPUMemoryRelease and RPi3GPUMemoryLock functions in the PlatformRPi3 unit for examples.

PS. The one function you don't need to change the implementation of is mbox_open which 
is just a dummy as you have it already, but you do still need to fix the declaration to 
be cdecl and public.

-------------------------mbox.c-------------------------

unsigned qpu_enable(int file_desc, unsigned enable)
unsigned execute_qpu(int file_desc, unsigned num_qpus, unsigned control, unsigned noflush, unsigned timeout)

-------------------------mbox.c-------------------------

&&&&&&&&&&&&&&&&&&&&&&&&platformrpi3.pas&&&&&&&&&&&&&&&&&&&&&&&&&&&&

function RPi3GPUMemoryAllocate(Length,Alignment,Flags:LongWord):THandle;
function RPi3GPUMemoryRelease(Handle:THandle):LongWord;
function RPi3GPUMemoryLock(Handle:THandle):LongWord;

GPUMemoryAllocateHandler:=RPi3GPUMemoryAllocate;
GPUMemoryReleaseHandler:=RPi3GPUMemoryRelease;
GPUMemoryLockHandler:=RPi3GPUMemoryLock;

function RPi3GPUMemoryAllocate(Length,Alignment,Flags:LongWord):THandle;
{Allocate GPU Memory from the Mailbox property tags channel}
var
 Size:LongWord;
 Response:LongWord;
 Header:PBCM2837MailboxHeader;
 Footer:PBCM2837MailboxFooter;
 Tag:PBCM2837MailboxTagAllocateMemory;
begin
 {}
 Result:=INVALID_HANDLE_VALUE;
 
 function RPi3GPUMemoryRelease(Handle:THandle):LongWord;
{Release GPU Memory from the Mailbox property tags channel}
var
 Size:LongWord;
 Response:LongWord;
 Header:PBCM2837MailboxHeader;
 Footer:PBCM2837MailboxFooter;
 Tag:PBCM2837MailboxTagReleaseMemory;
begin
 {}
 Result:=ERROR_INVALID_PARAMETER;
 
 {Calculate Size}
 Size:=SizeOf(TBCM2837MailboxHeader) + SizeOf(TBCM2837MailboxTagReleaseMemory) + SizeOf(TBCM2837MailboxFooter);
 
 {Allocate Mailbox Buffer}
 Header:=GetNoCacheAlignedMem(Size,SIZE_16); {Must be 16 byte aligned}
 if Header = nil then Header:=GetAlignedMem(Size,SIZE_16); {Must be 16 byte aligned}
 if Header = nil then Exit;
 try
  {Clear Buffer}
  FillChar(Header^,Size,0);
 
  {Setup Header}
  Header.Size:=Size;
  Header.Code:=BCM2837_MBOX_REQUEST_CODE;
 
  {Setup Tag}
  Tag:=PBCM2837MailboxTagReleaseMemory(PtrUInt(Header) + PtrUInt(SizeOf(TBCM2837MailboxHeader)));
  Tag.Header.Tag:=BCM2837_MBOX_TAG_RELEASE_MEMORY;
  Tag.Header.Size:=SizeOf(TBCM2837MailboxTagReleaseMemory) - SizeOf(TBCM2837MailboxTagHeader);
  Tag.Header.Length:=SizeOf(Tag.Request);
  Tag.Request.Handle:=Handle;
 
  {Setup Footer}
  Footer:=PBCM2837MailboxFooter(PtrUInt(Tag) + PtrUInt(SizeOf(TBCM2837MailboxTagReleaseMemory)));
  Footer.Tag:=BCM2837_MBOX_TAG_END;
  
  {Call Mailbox}
  Result:=MailboxPropertyCall(BCM2837_MAILBOX_0,BCM2837_MAILBOX0_CHANNEL_PROPERTYTAGS_ARMVC,Header,Response);
  if Result <> ERROR_SUCCESS then
   begin
    if PLATFORM_LOG_ENABLED then PlatformLogError('GPUMemoryRelease - MailboxPropertyCall Failed');
    Exit;
   end; 
  
  {Get Result}
  Result:=Tag.Response.Status;
 finally
  FreeMem(Header);
 end;
end;

function RPi3GPUMemoryLock(Handle:THandle):LongWord;
{Lock GPU Memory from the Mailbox property tags channel}
var
 Size:LongWord;
 Response:LongWord;
 Header:PBCM2837MailboxHeader;
 Footer:PBCM2837MailboxFooter;
 Tag:PBCM2837MailboxTagLockMemory;
begin
 {}
 Result:=0;
 
 {Calculate Size}
 Size:=SizeOf(TBCM2837MailboxHeader) + SizeOf(TBCM2837MailboxTagLockMemory) + SizeOf(TBCM2837MailboxFooter);
 
 {Allocate Mailbox Buffer}
 Header:=GetNoCacheAlignedMem(Size,SIZE_16); {Must be 16 byte aligned}
 if Header = nil then Header:=GetAlignedMem(Size,SIZE_16); {Must be 16 byte aligned}
 if Header = nil then Exit;
 try
  {Clear Buffer}
  FillChar(Header^,Size,0);
 
  {Setup Header}
  Header.Size:=Size;
  Header.Code:=BCM2837_MBOX_REQUEST_CODE;
 
  {Setup Tag}
  Tag:=PBCM2837MailboxTagLockMemory(PtrUInt(Header) + PtrUInt(SizeOf(TBCM2837MailboxHeader)));
  Tag.Header.Tag:=BCM2837_MBOX_TAG_LOCK_MEMORY;
  Tag.Header.Size:=SizeOf(TBCM2837MailboxTagLockMemory) - SizeOf(TBCM2837MailboxTagHeader);
  Tag.Header.Length:=SizeOf(Tag.Request);
  Tag.Request.Handle:=Handle;
 
  {Setup Footer}
  Footer:=PBCM2837MailboxFooter(PtrUInt(Tag) + PtrUInt(SizeOf(TBCM2837MailboxTagLockMemory)));
  Footer.Tag:=BCM2837_MBOX_TAG_END;
  
  {Call Mailbox}
  if MailboxPropertyCall(BCM2837_MAILBOX_0,BCM2837_MAILBOX0_CHANNEL_PROPERTYTAGS_ARMVC,Header,Response) <> ERROR_SUCCESS then
   begin
    if PLATFORM_LOG_ENABLED then PlatformLogError('GPUMemoryLock - MailboxPropertyCall Failed');
    Exit;
   end; 
  
  {Get Result}
  Result:=Tag.Response.Address;
 finally
  FreeMem(Header);
 end;
end;
 
&&&&&&&&&&&&&&&&&&&&&&&&platformrpi3.pas&&&&&&&&&&&&&&&&&&&&&&&&&&&&

In the mbox.c file there are 5 methods mem_alloc, mem_free, mem_lock,
mem_unlock, and execute_code. In Ultibo these are methods defined in platform.pas
with different names GPUMemoryAllocate, GPUMemoryRelease, GPUMemorylock, GPUMemoryUnlock, 
and GPUExecuteCode.  Wrappers are needed in Pascal such that C can call the existing
Pascal methods defined in platform.pas.  
mem_alloc		GPUMemoryAllocate
mem_free		GPUMemoryRelease
mem_lock		GPUMemorylock	
mem_unlock		GPUMemoryUnlock
GPUExecuteCode	GPUExecuteCode

To make Pascal visible to C the following needs to be defined ucpugpumailbox.pas.

{Prototypes for GPU Misc Handlers}
function mem_alloc(file_desc:Integer; size, align, flags:Longword):Longword; cdecl; public name 'mem_alloc';
function mem_free(file_desc:Integer;  handle:Longword):Longword; cdecl; public name 'mem_free';
function mem_lock( file_desc:Integer; handle:Longword):Longword; cdecl; public name 'mem_lock';
function mem_unlock(file_desc:Integer; handle:Longword):Longword; cdecl; public name 'mem_unlock';
function mbox_open():Integer; cdecl; public name 'mbox_open';
function execute_code(file_desc:Pointer; r0, r1, r2, r3, r4, r5:Longword):Longword; cdecl; public name 'execute_code';

The C Methods (mem_alloc, mem_free, mem_lock, mem_unlock, execute_code, qpu_enable, and
execute_qpu) all use the same way in setting the values of an unsigned array.

The 2 methods  qpu_enable & execute_qpu do not have Pascal defined methods.

mbox.c 
mem_alloc	Pascal	GPUMemoryAllocate

####################################################

unsigned mem_alloc(int file_desc, unsigned size, unsigned align, unsigned flags)
{
   int i=0;
   unsigned p[32];
   p[i++] = 0; // size
   p[i++] = 0x00000000; // process request

   p[i++] = 0x3000c; // (the tag id)
   p[i++] = 12; // (size of the buffer)
   p[i++] = 12; // (size of the data)
   p[i++] = size; // (num bytes? or pages?)
   p[i++] = align; // (alignment)
   p[i++] = flags; // (MEM_FLAG_L1_NONALLOCATING)

   p[i++] = 0x00000000; // end tag
   p[0] = i*sizeof *p; // actual size

   mbox_property(file_desc, p);
   return p[5];
}

####################################################

platform.pas

*****************************************************
{GPU Memory Functions}
function GPUMemoryAllocate(Length,Alignment,Flags:LongWord):THandle; inline;
{Allocate memory from the GPU}
begin
 {}
 if Assigned(GPUMemoryAllocateHandler) then
  begin
   Result:=GPUMemoryAllocateHandler(Length,Alignment,Flags);
  end
 else
  begin
   Result:=INVALID_HANDLE_VALUE;
  end;
end;

*****************************************************

ucpugpumailbox.pas

*****************************************************

function mem_alloc(file_desc:Integer; size, align, flags:Longword):Longword; cdecl; public name 'mem_alloc';

	{platform.pas lines 4973 - 4985
	type
    TGPUMemoryAllocate = function(Length,Alignment,Flags:LongWord):THandle; }

	begin
	Result := GPUMemoryAllocate(size, align, flags);
	end;
	
*****************************************************

mbox.c

mem_free	Pascal	GPUMemoryRelease
####################################################

unsigned mem_free(int file_desc, unsigned handle)
{
   int i=0;
   unsigned p[32];
   p[i++] = 0; // size
   p[i++] = 0x00000000; // process request

   p[i++] = 0x3000f; // (the tag id)
   p[i++] = 4; // (size of the buffer)
   p[i++] = 4; // (size of the data)
   p[i++] = handle;

   p[i++] = 0x00000000; // end tag
   p[0] = i*sizeof *p; // actual size

   mbox_property(file_desc, p);
   return p[5];
}

####################################################

platform.pas

*****************************************************

function GPUMemoryRelease(Handle:THandle):LongWord; inline;
{Release memory allocated from the GPU}
begin
 {}
 if Assigned(GPUMemoryReleaseHandler) then
  begin
   Result:=GPUMemoryReleaseHandler(Handle);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

*****************************************************

ucpugpumailbox.pas

*****************************************************

function mem_free(file_desc:Integer;  handle:Longword):Longword; cdecl; public name 'mem_free';

	{platform.pas lines 4989 - 5001
	type 
    TGPUMemoryRelease = function(Handle:THandle):LongWord; }
    
	begin
	Result := GPUMemoryRelease(handle);
	end;
	
*****************************************************


mem_lock	Pascal	 GPUMemoryLock

####################################################

unsigned mem_lock(int file_desc, unsigned handle)
{
   int i=0;
   unsigned p[32];
   p[i++] = 0; // size
   p[i++] = 0x00000000; // process request

   p[i++] = 0x3000d; // (the tag id)
   p[i++] = 4; // (size of the buffer)
   p[i++] = 4; // (size of the data)
   p[i++] = handle;

   p[i++] = 0x00000000; // end tag
   p[0] = i*sizeof *p; // actual size

   mbox_property(file_desc, p);
   return p[5];
}

####################################################

platform.pas

*****************************************************

function GPUMemoryLock(Handle:THandle):LongWord; inline;
{Lock memory allocated from the GPU and return an address}
begin
 {}
 if Assigned(GPUMemoryLockHandler) then
  begin
   Result:=GPUMemoryLockHandler(Handle);
  end
 else
  begin
   Result:=0;
  end;
end;

*****************************************************

ucpugpumailbox.pas

*****************************************************

function mem_lock(file_desc:Integer; handle:Longword):Longword; cdecl; public name 'mem_lock';

	{platform.pas lines 5005 - 5017
	type 
    TGPUMemoryLock = function(Handle:THandle):LongWord; }
    
	begin
	Result := GPUMemoryLock(handle);
	end;
	
*****************************************************

mem_unlock	Pascal	 GPUMemoryUnLock

####################################################

unsigned mem_unlock(int file_desc, unsigned handle)
{
   int i=0;
   unsigned p[32];
   p[i++] = 0; // size
   p[i++] = 0x00000000; // process request

   p[i++] = 0x3000e; // (the tag id)
   p[i++] = 4; // (size of the buffer)
   p[i++] = 4; // (size of the data)
   p[i++] = handle;

   p[i++] = 0x00000000; // end tag
   p[0] = i*sizeof *p; // actual size

   mbox_property(file_desc, p);
   return p[5];
}

####################################################

platform.pas

*****************************************************
function GPUMemoryUnlock(Handle:THandle):LongWord; inline;
{Unlock memory allocated from the GPU}
begin
 {}
 if Assigned(GPUMemoryUnlockHandler) then
  begin
   Result:=GPUMemoryUnlockHandler(Handle);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;	
 		
*****************************************************

ucpugpumailbox.pas

*****************************************************

function mem_unlock(file_desc:Integer; handle:Longword):Longword; cdecl; public name 'mem_unlock'; 

	begin
	Result := GPUMemoryUnlock(handle);
	end;

*****************************************************

execute_code	Pascal	GPUExecuteCode

####################################################

unsigned execute_code(int file_desc, unsigned code, unsigned r0, unsigned r1, unsigned r2, unsigned r3, unsigned r4, unsigned r5)
{
   int i=0;
   unsigned p[32];
   p[i++] = 0; // size
   p[i++] = 0x00000000; // process request

   p[i++] = 0x30010; // (the tag id)
   p[i++] = 28; // (size of the buffer)
   p[i++] = 28; // (size of the data)
   p[i++] = code;
   p[i++] = r0;
   p[i++] = r1;
   p[i++] = r2;
   p[i++] = r3;
   p[i++] = r4;
   p[i++] = r5;

   p[i++] = 0x00000000; // end tag
   p[0] = i*sizeof *p; // actual size

   mbox_property(file_desc, p);
   return p[5];
}

####################################################

platform.pas

*****************************************************

function GPUExecuteCode(Address:Pointer;R0,R1,R2,R3,R4,R5:LongWord):LongWord; inline;
{Execute a block of code on the GPU}
begin
 {}
 if Assigned(GPUExecuteCodeHandler) then
  begin
   Result:=GPUExecuteCodeHandler(Address,R0,R1,R2,R3,R4,R5);
  end
 else
  begin
   Result:=0;
  end;
end;

*****************************************************


ucpugpumailbox.pas

***************************************************** 

function execute_code(file_desc:Pointer; r0, r1, r2, r3, r4, r5:Longword):Longword; cdecl; public name 'execute_code';
 
	{platform.pas lines 5038 - 5050
	type 
    TGPUExecuteCode = function(Address:Pointer;R0,R1,R2,R3,R4,R5:LongWord):LongWord; }  
    
	begin
	Result := GPUExecuteCode(file_desc,R0,R1,R2,R3,R4,R5);
	end;

*****************************************************

var
 {QPU Handlers} 
 QPUExecuteCodeHandler:TQPUExecuteCode;
 QPUEnableHandler:TQPUEnable;	
 
 type
 {Prototypes for QPU Handlers}
  TQPUMemoryAllocate = function(file_desc:Integer; num_qpus,control,noflush,timeout:LongWord):THandle;cdecl; public name 'execute_qpu';
  TQPUEnable = function(file_desc:Integer; enable:LongWord):THandle;cdecl; public name 'qpu_enable';

https://petewarden.com/2014/08/07/how-to-optimize-raspberry-pi-code-using-its-gpu/
Pete Warden's blog

https://ultibo.org/forum/viewtopic.php?f=9&t=290
by Ultibo » Thu Sep 15, 2016 12:20 am

If you look at the /hello_fft/mailbox.c file you will see use of mailbox functions for mem_alloc, mem_free, mem_lock, execute_code 
and qpu_enable etc. These functions are mostly all available already in Ultibo through the mailbox interface. If you look in the 
Platform unit you will find GPUMemoryAllocate(), GPUMemoryRelease(), GPUMemoryLock() and GPUExecuteCode() etc which are calling 
the same mailbox functions used above.


The .hex files in the /hello_fft/hex folder seem to be the prebuilt binary versions of each of the files in the /hello_fft/qasm folder and only need to be copied to a block of memory allocated by the GPU before calling the appropriate function to ask it to execute the code.
Need to create the libs
/opt/vc/src/hello_pi/libs/vgfont/libvgfont.a
/opt/vc/src/hello_pi/libs/ilclient/libilclient.a

~/userland/host_applications/linux/apps/hello_pi/libs/ilclient $ make
~/userland/host_applications/linux/apps/hello_pi/libs/vgfont $ make

Nedd to create the folders where the libs

sudo mkdir -p /opt/vc/src/hello_pi/libs/vgfont
sudo mkdir -p /opt/vc/src/hello_pi/libs/ilclient

sudo cp  /home/pi/userland/host_applications/linux/apps/hello_pi/libs/ilclient/* /opt/vc/src/hello_pi/libs/ilclient/
sudo cp  /home/pi/userland/host_applications/linux/apps/hello_pi/libs/vgfont/* /opt/vc/src/hello_pi/libs/vgfont/

~/userland/host_applications/linux/apps/hello_pi/hello_teapot
make
sudo ./hello_teapot.bin

This required increasing the GPU Memory from 64 to 128
 
Re: programming gpu
Postby develone » Tue Apr 18, 2017 5:55 am
Hello All,
I did the hello_teapot example just required a make
pi@raspberrypi3:~/userland/host_applications/linux/apps/hello_pi/hello_teapot


This required increasing the GPU Memory from 64 to 128. This is quite impressive what the RPi can do.

  unsigned long int   	  	Longword
  float   	  				Single
  double   	  				Double 	  64-bit 

chgs made to 
git diff hello_fft_2d.c
diff --git a/host_applications/linux/apps/hello_pi/hello_fft/hello_fft_2d.c b/host_applications/linux/apps/hello_pi/hello_fft/hello_fft_2d.c
index a3868be..e2eca69 100644
--- a/host_applications/linux/apps/hello_pi/hello_fft/hello_fft_2d.c
+++ b/host_applications/linux/apps/hello_pi/hello_fft/hello_fft_2d.c
@@ -43,7 +43,7 @@ unsigned Microseconds(void) {
     //clock_gettime(CLOCK_REALTIME, &ts);
     return ts.tv_sec*1000000 + ts.tv_nsec/1000;
 }
-void fft_2d() {
+int main(int argc, char *argv[]) {
        printf("hello from ultibo\n");
            int x, y, ret, mb = mbox_open();
     unsigned t[4];
@@ -131,6 +131,6 @@ void fft_2d() {
     gpu_fft_release(fft_pass[1]);
     gpu_fft_trans_release(trans);
 
-    //return 0;
+    return 0;

Also, you will run into some things in gpu_fft_base.c that cause some errors because the function 
gpu_fft_get_host_info tries to call libbcm_host.so which isn't available in Ultibo, however all 
it is asking for are very simple pieces of information like the peripheral address and size which 
are readily available in the GlobalConfig unit of Ultibo. So quite likely this file can be left 
out (you need to check what the other functions do) and the relevant functions simulated in Pascal.

05/08/17

Location: Australia
Contact: Contact Ultibo
Re: Audio + VC4 assembly FFT
Unread postby Ultibo » Mon May 08, 2017 3:28 am
Hi develone,

develone wrote:
Any and all help is apprecaited.

You seem to have the Pascal declarations of the functions pretty much correct, in order to allow them to be called by the C code they need to be made public and also need to be declared with the C calling convention.

For example, if I take the mem_alloc function from your umailbox.pas unit the current declaration looks like this:
Code: Select all
function mem_alloc(file_desc:Integer; size, align, flags:Longword):Longword;

To support calling from C it should look like this:
Code: Select all
function mem_alloc(file_desc:Integer; size, align, flags:Longword):Longword; cdecl; public name 'mem_alloc';

The cdecl keyword gives the correct calling convention and the public name keyword makes it visible to external code.

Most of these mailbox functions are already available in the Platform unit, so what you need to do (except for a couple that are missing) is simply to make those available with the correct name and C calling convention.

Taking the mem_alloc example again, this is what the implementation part would look like in order to expose the existing function from Ultibo:

Code: Select all
function mem_alloc(file_desc:Integer; size, align, flags:Longword):Longword; cdecl;
begin
   Result := GPUMemoryAllocate(size, align, flags);
end;

So in essence this is just creating a wrapper that allows C to call the Pascal functions.

As per my earlier post, the qpu_enable and execute_qpu are not currently present in Ultibo but using the existing functions and the mailbox.c code from hello_fft it should be possible to create Pascal implementations of those as well. See the RPi3GPUMemoryAllocate, RPi3GPUMemoryRelease and RPi3GPUMemoryLock functions in the PlatformRPi3 unit for examples.

PS. The one function you don't need to change the implementation of is mbox_open which is just a dummy as you have it already, but you do still need to fix the declaration to be cdecl and public.
